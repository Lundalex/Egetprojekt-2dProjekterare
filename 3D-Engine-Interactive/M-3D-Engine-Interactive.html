<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="S-Html-Inputs.JS"></script>
    <script src="S-MainLoop-Extensions.JS"></script>
    <script src="S-Important-Extensions.JS"></script>
    <script src="S-User-Events.JS"></script>
    
    <title>Unity(TM)</title>
</head>
<body onclick="OnClickFunction(event)" onmousedown="MouseDownFunction(event)" onmouseup="MouseUpFunction(event)" onwheel="ScrollFunction(event)">
    
<h1>Unity(TM)</h1>

    <div style="display: flex; flex-direction: row">

        <canvas id="Canvas" width="800" height="800" style="border:10px solid #00ff80;"></canvas>

        <div style="width: 10px;"></div>

        <div style="display: flex; flex-direction: column;">

            <h1 style="font-weight: bolder;">Camera:</h1>

        <div style="display: flex; flex-direction: column;">
        <div style="width: 180; height: 50; display: flex; flex-direction: row">
            <div style="height: 50px; width: 50px ;background-color: rgb(69, 218, 32)"onclick="MoveLeft()">Left</div>
            <div style="height: 50px; width: 50px; background-color: #0004ff;"onclick="MoveAhead()">Ahead</div>
            <div style="height: 50px; width: 50px; background-color: rgb(69, 218, 32)"onclick="MoveRight()">Right</div>
            </div>
            <div style="width: 120; height: 50; display: flex; flex-direction: row">
            <div style="height: 50px; width: 50px; background-color: white"></div>
            <div style="height: 50px; width: 50px; background-color: rgb(69, 218, 32)"onclick="MoveBack()">Back</div>
            </div>
        </div>
        <br>
        <div style="display: flex; flex-direction: column;">
            <div style="width: 150; height: 50; display: flex; flex-direction: row">
            <div style="height: 50px; width: 50px; background-color: white"></div>
            <div style="height: 50px; width: 50px; background-color: rgb(255, 251, 0)"onclick="MoveUp()">Up</div>
            </div>
            <div style="width: 150; height: 50; display: flex; flex-direction: row">
            <div style="height: 50px; width: 50px; background-color: white"></div>
            <div style="height: 50px; width: 50px; background-color: rgb(203, 32, 218)"onclick="MoveDown()">Down</div>
            </div>
        </div>

        <h1 style="font-weight: bolder;">Settings:</h1>

        <button style="width: 150px; font-weight: 1000;" onclick="Start()">Start Program</button>
        <button style="width: 150px; font-weight: 1000;" onclick="QuickStart()">Quick Start</button>
        <br>
        <br><br>

        <br>

            <label>Focal Length:</label>
            <div style="display: flex; flex-direction: row"><input style="width: 150px;" type="text" id="3"><div id="7"></div></div>
            <button style="width: 150px;" onclick="SubmitSettings()">Submit Settings</button>
            

    </div>

    <div style="width: 50px;"></div>


    <div style="display: flex; flex-direction: column;">
    <h1>Add Object:</h1>
    <button style="width: 150px;" onclick="AddCubeObject()">AddCubeObject</button>
    <div>
    <input type="radio" name="1" value="Manipulate Path" onchange="ChangeManipulatePath()"><label>Manipulate Path</label><br>
    <input type="radio" name="1" value="Manipulate Point" onchange="ChangeManipulatePoint()"><label>Manipulate Point</label><br>
    <input type="radio" name="1" value="Manipulate Object" onchange="ChangeManipulateObject()"><label>Manipulate Object</label><br>
</div>
<p>(Arrowkeys, Shift, Spacebar) for movement (selected)</p>
<p>Onscreen buttons for camera movement</p>
<p>Onscreen buttons for camera movement</p>
<p>(Manipulate Object + Scroll) for Scaling object</p>
<p>(Key "b") to show Animation Pathing</p>

    </div>

<script>
    // All Global Variables
let canvas = document.getElementById("Canvas")
let ctx = canvas.getContext("2d")
let context = canvas.getContext('2d')

let ShellX = []
let ShellY = []
let ShellZ = []

let KeyPress = ""

let Manipulate = ""

let ScrollY = "None"

let TX = 0
let TY = 0
let TZ = 0
let MX = 0
let MY = 0
let MZ = 0

let XPosNeg = []
let ZPosNeg = []
let YPosNeg = []
let ZYPosNeg = []

let ShellLeaderX = []
let ShellLeaderY = []
let ShellLeaderZ = []

let ShellXProjected = [[]]
let ShellYProjected = [[]]

let AnimationPathXProjected = [[]]
let AnimationPathYProjected = [[]]

let LeaderStyle = []

let Avgstyle = 0

let FocalLength = 0

let FrameAmount = 0

let MarkedPoints = [[]]
let MarkedObject = []

let FoundObjectNumber = 100

let ObjectAnimationInstructionsX = [[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]]]
let ObjectAnimationInstructionsY = [[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]]]
let ObjectAnimationInstructionsZ = [[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]],[[0],[0],[0],[0],[0],[0],[0],[0],[0]]]

let AnimationX = []
let AnimationY = []
let AnimationZ = []

let ChosenPathStage = 0

let LastMouseDownX = 0
let LastMouseDownY = 0

let LastMouseUpX = 0
let LastMouseUpY = 0

let TotalAnimationX = []
let TotalAnimationY = []
let TotalAnimationZ = []

let ShowAnimationPathing = false

let AnimateFrame = 0
    // All Global Variables






function MainLoop(){
    // Reset Canvas
    ctx.beginPath();
    ctx.rect(00, 00, 800, 800);
    ctx.fillStyle = "white";
    ctx.fill();
    // Reset Canvas






    // INCREMENT COMMANDS
if(Manipulate == "Path"){
switch (KeyPress) {
    case "ArrowDown":
    ObjectAnimationInstructionsZ[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsZ[FoundObjectNumber][ChosenPathStage]) - 20

    break;
    case "ArrowUp":
    ObjectAnimationInstructionsZ[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsZ[FoundObjectNumber][ChosenPathStage]) + 20
    
    break;
    case "ArrowLeft":
    ObjectAnimationInstructionsX[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsX[FoundObjectNumber][ChosenPathStage]) - 20
    
    break;
    case "ArrowRight":
    ObjectAnimationInstructionsX[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsX[FoundObjectNumber][ChosenPathStage]) + 20
    
    break;
    case "SpaceBar":
    ObjectAnimationInstructionsY[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsY[FoundObjectNumber][ChosenPathStage]) - 20
    break;

    case "Shift":
    ObjectAnimationInstructionsY[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsY[FoundObjectNumber][ChosenPathStage]) + 20
    
    break;

    default:
        break;
}

}
else if(Manipulate == "Point"){

for (let i = 0; i < MarkedPoints.length; i++) {

    for (let o = 0; o < MarkedPoints[i].length; o++) {

        if(MarkedPoints[i][o] == true){

            switch (KeyPress) {
                case "ArrowDown":
                ShellZ[i][o] -= 20

                break;
                case "ArrowUp":
                ShellZ[i][o] += 20

                break;
                case "ArrowLeft":
                ShellX[i][o] -= 20

                break;
                case "ArrowRight":
                ShellX[i][o] += 20

                break;
                case "SpaceBar":
                ShellY[i][o] -= 20

                break;
                case "Shift":
                ShellY[i][o] += 20

                break;

                default:
                break;
            }
        }
    }
}


}


else if(Manipulate == "Object"){
    switch (KeyPress) {
    case "ArrowDown":
    ShellLeaderZ[FoundObjectNumber] -= 20

    break;
    case "ArrowUp":
    ShellLeaderZ[FoundObjectNumber] += 20
    
    break;
    case "ArrowLeft":
    ShellLeaderX[FoundObjectNumber] -= 20
    
    break;
    case "ArrowRight":
    ShellLeaderX[FoundObjectNumber] += 20
    
    break;
    case "SpaceBar":
    ShellLeaderY[FoundObjectNumber] -= 20

    break;
    case "Shift":
    ShellLeaderY[FoundObjectNumber] += 20
    
    break;

    default:
        break;
}
}


// Scaling
if(ScrollY != "None"){

    let Scalefactor = 0

if(ScrollY == "Up"){
    Scalefactor = 1.05
}

else{
    Scalefactor = 0.95    
}

    for (let i = 0; i < ShellX[FoundObjectNumber].length; i++) {
        ShellX[FoundObjectNumber][i] *= Scalefactor
        ShellY[FoundObjectNumber][i] *= Scalefactor
        ShellZ[FoundObjectNumber][i] *= Scalefactor
        
    }
}
// Scaling



    // INCREMENT COMMANDS









    // Add Animation Frame Value !!!
if(AnimateFrame > 400){
    AnimateFrame = 1
}
else{
    AnimateFrame ++
}

for (let i = 0; i < ShellX.length; i++) {
    
let CurrentAnimationStage = Math.floor(AnimateFrame/100)
let FrameInAnimationStage = AnimateFrame % 100

AnimationX[i] = 0
AnimationY[i] = 0
AnimationZ[i] = 0

for (let o = 0; o < CurrentAnimationStage; o++) {

    AnimationX[i] += Number(ObjectAnimationInstructionsX[i][o])
    AnimationY[i] += Number(ObjectAnimationInstructionsY[i][o])
    AnimationZ[i] += Number(ObjectAnimationInstructionsZ[i][o])

}

AnimationX[i] += Number(ObjectAnimationInstructionsX[i][CurrentAnimationStage]) * 0.01 * FrameInAnimationStage
AnimationY[i] += Number(ObjectAnimationInstructionsY[i][CurrentAnimationStage]) * 0.01 * FrameInAnimationStage
AnimationZ[i] += Number(ObjectAnimationInstructionsZ[i][CurrentAnimationStage]) * 0.01 * FrameInAnimationStage

}



if(ShowAnimationPathing == true){

for (let i = 0; i < ObjectAnimationInstructionsX.length; i++) {

    TotalAnimationX[i] = []
    TotalAnimationY[i] = []
    TotalAnimationZ[i] = []


        TotalAnimationX[i][0] = Number(ObjectAnimationInstructionsX[i][0])
        TotalAnimationY[i][0] = Number(ObjectAnimationInstructionsY[i][0])
        TotalAnimationZ[i][0] = Number(ObjectAnimationInstructionsZ[i][0])


    for (let o = 1; o < ObjectAnimationInstructionsX[i].length; o++) {

        TotalAnimationX[i][o] = Number(TotalAnimationX[i][o-1]) + Number(ObjectAnimationInstructionsX[i][o])
        TotalAnimationY[i][o] = Number(TotalAnimationY[i][o-1]) + Number(ObjectAnimationInstructionsY[i][o])
        TotalAnimationZ[i][o] = Number(TotalAnimationZ[i][o-1]) + Number(ObjectAnimationInstructionsZ[i][o])

    }




}


}






    // Add Animation Frame Value
    // Shell X/Y Projected
    for (let i = 0; i < ShellX.length; i++) {
        ShellXProjected[i] = []
        ShellYProjected[i] = []

        for (let o = 0; o < ShellX[i].length; o++) {
            let X = ShellX[i][o] + ShellLeaderX[i] + Number(AnimationX[i])
            let Y = ShellY[i][o] + ShellLeaderY[i] + Number(AnimationY[i])
            let Z = ShellZ[i][o] + ShellLeaderZ[i] + Number(AnimationZ[i])

            ShellXProjected[i][o] = ((X * FocalLength) / (Z + FocalLength))
            ShellYProjected[i][o] = ((Y * FocalLength) / (Z + FocalLength))
        }
    }
    // Shell X/Y Projected
    // Add Animation Frame Value




    // Animation Path X/Y Projected

if(ShowAnimationPathing == true){

    for (let i = 0; i < ShellLeaderX.length; i++) {

        AnimationPathXProjected[i] = []
        AnimationPathYProjected[i] = []

        for (let o = 0; o < TotalAnimationX[i].length; o++) {
            
            let X = ShellLeaderX[i] + TotalAnimationX[i][o]
            let Y = ShellLeaderY[i] + TotalAnimationY[i][o]
            let Z = ShellLeaderZ[i] + TotalAnimationZ[i][o]
            
            AnimationPathXProjected[i][o] = ((X * FocalLength) / (Z + FocalLength))
            AnimationPathYProjected[i][o] = ((Y * FocalLength) / (Z + FocalLength))
        }

        AnimationPathXProjected[i].unshift((ShellLeaderX[i] * FocalLength) / (ShellLeaderZ[i] + FocalLength))
        AnimationPathYProjected[i].unshift((ShellLeaderY[i] * FocalLength) / (ShellLeaderZ[i] + FocalLength))
    }

}

    // Animation Path X/Y Projected







    // Projection - Object Shells
    for (let i = 0; i < ShellXProjected.length; i++) {
        // Object Marked
        if(MarkedObject[i] == true){
            for (let o = 0; o < ShellXProjected[i].length; o++) {
            
            ctx.moveTo(400+Number(ShellXProjected[i][o]),400+Number(ShellYProjected[i][o]));
            ctx.lineTo(400+Number(ShellXProjected[i][o+1]),400+Number(ShellYProjected[i][o+1]));
            ctx.strokeStyle = "orange"
            ctx.lineWidth = 2
            ctx.stroke()
        }
        // Point Marked (in Marked Object)
        for (let o = 0; o < ShellXProjected[i].length; o++) {
            
            if(MarkedPoints[i][o] == true){

                ctx.moveTo(400+Number(ShellXProjected[i][o]-10),400+Number(ShellYProjected[i][o]-10));
                ctx.lineTo(400+Number(ShellXProjected[i][o]+10),400+Number(ShellYProjected[i][o]+10));
                ctx.strokeStyle = "red"
                ctx.lineWidth = 2
                ctx.stroke()
                ctx.moveTo(400+Number(ShellXProjected[i][o]+10),400+Number(ShellYProjected[i][o]-10));
                ctx.lineTo(400+Number(ShellXProjected[i][o]-10),400+Number(ShellYProjected[i][o]+10))
                ctx.stroke()
            }
        }

        }
        // Object Not Marked
        else{
        for (let o = 0; o < ShellXProjected[i].length; o++) {
            
            ctx.moveTo(400+Number(ShellXProjected[i][o]),400+Number(ShellYProjected[i][o]));
            ctx.lineTo(400+Number(ShellXProjected[i][o+1]),400+Number(ShellYProjected[i][o+1]))
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2
            ctx.stroke()
        }}
        
    }
    // Projection - Object Shells


    // Projection - Animation Pathing
if(ShowAnimationPathing == true){

    for (let i = 0; i < AnimationPathXProjected.length; i++) {

        for (let o = 0; o < AnimationPathXProjected[i].length; o++) {

            ctx.moveTo(400+Number(AnimationPathXProjected[i][o]),400+Number(AnimationPathYProjected[i][o]));
            ctx.lineTo(400+Number(AnimationPathXProjected[i][o+1]),400+Number(AnimationPathYProjected[i][o+1]));
            ctx.strokeStyle = "purple"
            ctx.lineWidth = 2
            ctx.stroke()



        
        }
    }
}
    // Projection - Animation Pathing


// Reset KeyPress, ScrollY
    KeyPress = "NoKey"
    ScrollY = "None"
}
</script>


</body>
</html>