<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="S-Html-Inputs.JS"></script>
    <script src="S-MainLoop-Extensions.JS"></script>
    <script src="S-Important-Extensions.JS"></script>
    <script src="S-User-Events.JS"></script>
    
    <title>Unity(TM)</title>
</head>
<body onclick="OnClickFunction(event)" onmousedown="MouseDownFunction(event)" onmouseup="MouseUpFunction(event)" onwheel="ScrollFunction(event)" style="background-color: #909090">
    
<h1 style="color:rgb(255, 238, 0)">Unity(TM)</h1>

    <div style="display: flex; flex-direction: row">

        <canvas id="Canvas" width="800" height="800" style="border:10px solid #a200ff;"></canvas>

        <div style="width: 10px;"></div>

        <div style="display: flex; flex-direction: column;" style="padding: 20px;" style="background-color: burlywood;">

            <h1 style="font-weight: bolder;">Camera:</h1>

        <div style="display: flex; flex-direction: column;">
        <div style="width: 180; height: 50; display: flex; flex-direction: row">
            <div style="height: 50px; width: 50px ;background-color: rgb(69, 218, 32)"onclick="MoveLeft()">Left</div>
            <div style="height: 50px; width: 50px; background-color: #0004ff;"onclick="MoveAhead()">Ahead</div>
            <div style="height: 50px; width: 50px; background-color: rgb(69, 218, 32)"onclick="MoveRight()">Right</div>
            </div>
            <div style="width: 120; height: 50; display: flex; flex-direction: row">
            <div style="height: 50px; width: 50px; background-color: #909090"></div>
            <div style="height: 50px; width: 50px; background-color: rgb(69, 218, 32)"onclick="MoveBack()">Back</div>
            </div>
        </div>
        <br>
        <div style="display: flex; flex-direction: column;">
            <div style="width: 150; height: 50; display: flex; flex-direction: row">
            <div style="height: 50px; width: 50px; background-color: #909090"></div>
            <div style="height: 50px; width: 50px; background-color: rgb(255, 251, 0)"onclick="MoveUp()">Up</div>
            </div>
            <div style="width: 150; height: 50; display: flex; flex-direction: row">
            <div style="height: 50px; width: 50px; background-color: #909090"></div>
            <div style="height: 50px; width: 50px; background-color: rgb(203, 32, 218)"onclick="MoveDown()">Down</div>
            </div>
        </div>

        <h1 style="font-weight: bolder;">Settings:</h1>
        <button style="width: 150px;" onclick="AddCubeObject()">AddCubeObject</button>
        <div>
        <input type="radio" name="1" value="Manipulate Path" onchange="ChangeManipulatePath()"><label>Manipulate Path</label><br>
        <input type="radio" name="1" value="Manipulate Point" onchange="ChangeManipulatePoint()"><label>Manipulate Point</label><br>
        <input type="radio" name="1" value="Manipulate Object" onchange="ChangeManipulateObject()"><label>Manipulate Object</label><br>
    </div>
        <button style="width: 150px; font-weight: 1000;" onclick="Start()">Start Program</button>
        <button style="width: 150px; font-weight: 1000;" onclick="QuickStart()">Quick Start</button>
        <br>
        <br><br>

        <br>

            <label>Focal Length:</label>
            <div style="display: flex; flex-direction: row"><input style="width: 150px;" type="text" id="3"><div id="7"></div></div>
            <button style="width: 150px;" onclick="SubmitSettings()">Submit Settings</button>
            

    </div>

    <div style="width: 50px;"></div>


    <div style="display: flex; flex-direction: column;">

        <!-- INSTRUCTIONS -->
<p>(Arrowkeys, Shift, Spacebar) for movement (selected)</p>
<p>Onscreen buttons for camera movement</p>
<p>Onscreen buttons for camera movement</p>
<p>(Manipulate Object + Scroll) for Scaling object</p>
<p>(Key: "b") to show Animation Pathing</p>
<p>(Keys: "k", "l", "m", "n") to change Focus Animation Stage</p>
<p>(Key: "v") to Stop Program</p>

    </div>

<script>
    // All Global Variables
let canvas = document.getElementById("Canvas")
let ctx = canvas.getContext("2d")
let context = canvas.getContext('2d')

let ShellX = []
let ShellY = []
let ShellZ = []

let KeyPress = ""

let Manipulate = ""

let ScrollY = "None"

let TX = 0
let TY = 0
let TZ = 0
let MX = 0
let MY = 0
let MZ = 0

let XPosNeg = []
let ZPosNeg = []
let YPosNeg = []
let ZYPosNeg = []

let ShellLeaderX = []
let ShellLeaderY = []
let ShellLeaderZ = []

let ShellXProjected = [[]]
let ShellYProjected = [[]]

let AnimationPathXProjected = [[]]
let AnimationPathYProjected = [[]]

let LeaderStyle = []

let Avgstyle = 0

let FocalLength = 700

let FrameAmount = 10000

let MarkedPoints = [[]]
let MarkedObject = []

let FoundObjectNumber = 100

let ObjectAnimationInstructionsX = []
let ObjectAnimationInstructionsY = []
let ObjectAnimationInstructionsZ = []
GenerateInfArrForObjectAnimationInstructions()

let AnimationX = []
let AnimationY = []
let AnimationZ = []

let ChosenPathStage = 0

let LastMouseDownX = 0
let LastMouseDownY = 0

let LastMouseUpX = 0
let LastMouseUpY = 0

let TotalAnimationX = []
let TotalAnimationY = []
let TotalAnimationZ = []

let ShowAnimationPathing = false

let AnimateFrame = 0

let RunProgram = false
    // All Global Variables






function MainLoop(){

    ResetCanvas()

    // (Manipulate path, object, point)
    DoManipulation()

    DoScaling()

    DoCalculateAnimation()

    // Prepare Projection Arrays
    ProjectShell2D()

    ProjectAnimationPath2D()
    //
    
    // Draw On Canvas
    CanvasDrawObjectShells()

    CanvasDrawAnimationPathing()
    //


    KeyPress = "NoKey"
    ScrollY = "None"




if(RunProgram == true){
    setTimeout(MainLoop, 20)
}
else{
    ResetCanvas()
}
}
   // END OF MAIN LOOP





    // Reset Canvas Function
    function ResetCanvas(){
    ctx.beginPath();
    ctx.rect(00, 00, 800, 800);
    ctx.fillStyle = "white";
    ctx.fill();
}
    // Reset Canvas Function




    
    // Manipulate Path/Object/Point Function
function DoManipulation(){
    if(Manipulate == "Path"){
        switch (KeyPress) {
            case "ArrowDown":
            ObjectAnimationInstructionsZ[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsZ[FoundObjectNumber][ChosenPathStage]) - 20
        
            break;
            case "ArrowUp":
            ObjectAnimationInstructionsZ[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsZ[FoundObjectNumber][ChosenPathStage]) + 20
            
            break;
            case "ArrowLeft":
            ObjectAnimationInstructionsX[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsX[FoundObjectNumber][ChosenPathStage]) - 20
            
            break;
            case "ArrowRight":
            ObjectAnimationInstructionsX[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsX[FoundObjectNumber][ChosenPathStage]) + 20
            
            break;
            case "SpaceBar":
            ObjectAnimationInstructionsY[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsY[FoundObjectNumber][ChosenPathStage]) - 20
            break;
        
            case "Shift":
            ObjectAnimationInstructionsY[FoundObjectNumber][ChosenPathStage] = Number(ObjectAnimationInstructionsY[FoundObjectNumber][ChosenPathStage]) + 20
            break;
        
            default:
                break;
        }
        
        }
        else if(Manipulate == "Point"){
        
        for (let i = 0; i < MarkedPoints.length; i++) {
        
            for (let o = 0; o < MarkedPoints[i].length; o++) {
        
                if(MarkedPoints[i][o] == true){
        
                    switch (KeyPress) {
                        case "ArrowDown":
                        ShellZ[i][o] -= 20
        
                        break;
                        case "ArrowUp":
                        ShellZ[i][o] += 20
        
                        break;
                        case "ArrowLeft":
                        ShellX[i][o] -= 20
        
                        break;
                        case "ArrowRight":
                        ShellX[i][o] += 20
        
                        break;
                        case "SpaceBar":
                        ShellY[i][o] -= 20
        
                        break;
                        case "Shift":
                        ShellY[i][o] += 20
        
                        break;
        
                        default:
                        break;
                    }
                }
            }
        }
        }
        
        else if(Manipulate == "Object"){
            switch (KeyPress) {
            case "ArrowDown":
            ShellLeaderZ[FoundObjectNumber] -= 20
        
            break;
            case "ArrowUp":
            ShellLeaderZ[FoundObjectNumber] += 20
            
            break;
            case "ArrowLeft":
            ShellLeaderX[FoundObjectNumber] -= 20
            
            break;
            case "ArrowRight":
            ShellLeaderX[FoundObjectNumber] += 20
            
            break;
            case "SpaceBar":
            ShellLeaderY[FoundObjectNumber] -= 20
        
            break;
            case "Shift":
            ShellLeaderY[FoundObjectNumber] += 20
            
            break;
        
            default:
                break;
        }
    }
}
    // Manipulate Path/Object/Point Function





    // Apply Scaling Function
function DoScaling(){
    if(ScrollY != "None"){

        let Scalefactor = 0
    
    if(ScrollY == "Up"){
        Scalefactor = 1.05
    }
    
    else{
        Scalefactor = 0.95    
    }
    
        for (let i = 0; i < ShellX[FoundObjectNumber].length; i++) {
            ShellX[FoundObjectNumber][i] *= Scalefactor
            ShellY[FoundObjectNumber][i] *= Scalefactor
            ShellZ[FoundObjectNumber][i] *= Scalefactor
            
        }
    }
}
    // Apply Scaling Function





    // Calculate Animation Values per Frame Function
function DoCalculateAnimation(){

    if(AnimateFrame > 400){
        AnimateFrame = 1
    }
    else{
        AnimateFrame ++
    }
    
    for (let i = 0; i < ShellX.length; i++) {
        
    let CurrentAnimationStage = Math.floor(AnimateFrame/100)
    let FrameInAnimationStage = AnimateFrame % 100
    
    AnimationX[i] = 0
    AnimationY[i] = 0
    AnimationZ[i] = 0
    
    for (let o = 0; o < CurrentAnimationStage; o++) {
    
        AnimationX[i] += Number(ObjectAnimationInstructionsX[i][o])
        AnimationY[i] += Number(ObjectAnimationInstructionsY[i][o])
        AnimationZ[i] += Number(ObjectAnimationInstructionsZ[i][o])
    
    }
    
    AnimationX[i] += Number(ObjectAnimationInstructionsX[i][CurrentAnimationStage]) * 0.01 * FrameInAnimationStage
    AnimationY[i] += Number(ObjectAnimationInstructionsY[i][CurrentAnimationStage]) * 0.01 * FrameInAnimationStage
    AnimationZ[i] += Number(ObjectAnimationInstructionsZ[i][CurrentAnimationStage]) * 0.01 * FrameInAnimationStage
    
    }
    
    
    
    if(ShowAnimationPathing == true){
    
    for (let i = 0; i < ObjectAnimationInstructionsX.length; i++) {
    
        TotalAnimationX[i] = []
        TotalAnimationY[i] = []
        TotalAnimationZ[i] = []
    
    
            TotalAnimationX[i][0] = Number(ObjectAnimationInstructionsX[i][0])
            TotalAnimationY[i][0] = Number(ObjectAnimationInstructionsY[i][0])
            TotalAnimationZ[i][0] = Number(ObjectAnimationInstructionsZ[i][0])
    
    
        for (let o = 1; o < ObjectAnimationInstructionsX[i].length; o++) {
    
            TotalAnimationX[i][o] = Number(TotalAnimationX[i][o-1]) + Number(ObjectAnimationInstructionsX[i][o])
            TotalAnimationY[i][o] = Number(TotalAnimationY[i][o-1]) + Number(ObjectAnimationInstructionsY[i][o])
            TotalAnimationZ[i][o] = Number(TotalAnimationZ[i][o-1]) + Number(ObjectAnimationInstructionsZ[i][o])
    
        }
    }
    }
}
    // Calculate Animation Values per Frame Function





    // Project Shell X/Y/Z -> 2D(X, Y) Function
function ProjectShell2D(){
    for (let i = 0; i < ShellX.length; i++) {
        ShellXProjected[i] = []
        ShellYProjected[i] = []

        for (let o = 0; o < ShellX[i].length; o++) {
            // Add Animation Frame Values
            let X = ShellX[i][o] + ShellLeaderX[i] + Number(AnimationX[i])
            let Y = ShellY[i][o] + ShellLeaderY[i] + Number(AnimationY[i])
            let Z = ShellZ[i][o] + ShellLeaderZ[i] + Number(AnimationZ[i])

            ShellXProjected[i][o] = ((X * FocalLength) / (Z + FocalLength))
            ShellYProjected[i][o] = ((Y * FocalLength) / (Z + FocalLength))
        }
    }
}
    // Project Shell X/Y/Z -> 2D(X, Y) Function





    // Project per Object Animation Path X/Y/Z -> 2D(X, Y) Function
function ProjectAnimationPath2D(){
if(ShowAnimationPathing == true){

    for (let i = 0; i < ShellLeaderX.length; i++) {

        AnimationPathXProjected[i] = []
        AnimationPathYProjected[i] = []

        for (let o = 0; o < TotalAnimationX[i].length; o++) {
            
            let X = ShellLeaderX[i] + TotalAnimationX[i][o]
            let Y = ShellLeaderY[i] + TotalAnimationY[i][o]
            let Z = ShellLeaderZ[i] + TotalAnimationZ[i][o]
            
            AnimationPathXProjected[i][o] = ((X * FocalLength) / (Z + FocalLength))
            AnimationPathYProjected[i][o] = ((Y * FocalLength) / (Z + FocalLength))
        }

        AnimationPathXProjected[i].unshift((ShellLeaderX[i] * FocalLength) / (ShellLeaderZ[i] + FocalLength))
        AnimationPathYProjected[i].unshift((ShellLeaderY[i] * FocalLength) / (ShellLeaderZ[i] + FocalLength))
    }

}
}
    // Project per Object Animation Path X/Y/Z -> 2D(X, Y) Function





    // Canvas Draw Object Shells with Marking Function
function CanvasDrawObjectShells(){
    for (let i = 0; i < ShellXProjected.length; i++) {
        // Object Marked
        if(MarkedObject[i] == true){
            for (let o = 0; o < ShellXProjected[i].length; o++) {
            
            ctx.moveTo(400+Number(ShellXProjected[i][o]),400+Number(ShellYProjected[i][o]));
            ctx.lineTo(400+Number(ShellXProjected[i][o+1]),400+Number(ShellYProjected[i][o+1]));
            ctx.strokeStyle = "orange"
            ctx.lineWidth = 2
            ctx.stroke()
        }
        // Point Marked (in Marked Object)
        for (let o = 0; o < ShellXProjected[i].length; o++) {
            
            if(MarkedPoints[i][o] == true){

                ctx.moveTo(400+Number(ShellXProjected[i][o]-10),400+Number(ShellYProjected[i][o]-10));
                ctx.lineTo(400+Number(ShellXProjected[i][o]+10),400+Number(ShellYProjected[i][o]+10));
                ctx.strokeStyle = "red"
                ctx.lineWidth = 2
                ctx.stroke()
                ctx.moveTo(400+Number(ShellXProjected[i][o]+10),400+Number(ShellYProjected[i][o]-10));
                ctx.lineTo(400+Number(ShellXProjected[i][o]-10),400+Number(ShellYProjected[i][o]+10))
                ctx.stroke()
            }
        }

        }
        // Object Not Marked
        else{
        for (let o = 0; o < ShellXProjected[i].length; o++) {
            
            ctx.moveTo(400+Number(ShellXProjected[i][o]),400+Number(ShellYProjected[i][o]));
            ctx.lineTo(400+Number(ShellXProjected[i][o+1]),400+Number(ShellYProjected[i][o+1]))
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2
            ctx.stroke()
        }}
        
    }
}
    // Canvas Draw Object Shells with Marking Function





    // Canvas draw Animation Pathing Visualisation Function
function CanvasDrawAnimationPathing(){
    if(ShowAnimationPathing == true){

        for (let i = 0; i < AnimationPathXProjected.length; i++) {
    
            for (let o = 0; o < AnimationPathXProjected[i].length; o++) {
    
                ctx.moveTo(400+Number(AnimationPathXProjected[i][o]),400+Number(AnimationPathYProjected[i][o]));
                ctx.lineTo(400+Number(AnimationPathXProjected[i][o+1]),400+Number(AnimationPathYProjected[i][o+1]));
                ctx.strokeStyle = "purple"
                ctx.lineWidth = 2
                ctx.stroke()
            }
        }
    }
}
    // Canvas draw Animation Pathing Visualisation Function




















</script>


</body>
</html>